package xyz.xenondevs.novagradle.task

import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.Opcodes
import org.objectweb.asm.tree.ClassNode
import xyz.xenondevs.bytebase.asm.buildInsnList
import xyz.xenondevs.bytebase.util.MethodNode
import xyz.xenondevs.bytebase.util.insertBeforeEvery
import xyz.xenondevs.novagradle.Versions
import xyz.xenondevs.novagradle.util.toClassFilePath
import java.io.File

private const val PAPER_PLUGIN_YML = "paper-plugin.yml"
private const val NOVA_ADDON_YML = "nova-addon.yml"
private const val JAVA_PLUGIN_NAME = "xyz.xenondevs.addonloader.JavaPlugin"
private const val BOOTSTRAPPER_NAME = "xyz.xenondevs.addonloader.Bootstrapper"
private const val PLUGIN_LOADER_NAME = "xyz.xenondevs.addonloader.PluginLoader"
private val JAVA_PLUGIN_INTERNAL_NAME = JAVA_PLUGIN_NAME.replace('.', '/')
private val BOOTSTRAPPER_INTERNAL_NAME = BOOTSTRAPPER_NAME.replace('.', '/')
private val PLUGIN_LOADER_INTERNAL_NAME = PLUGIN_LOADER_NAME.replace('.', '/')

internal abstract class PrepareAddonJar : DefaultTask() {
    
    @get:Input
    abstract val addonName: Property<String>
    
    @get:Input
    abstract val version: Property<String>
    
    @get:Input
    abstract val main: Property<String>
    
    @get:Input
    @get:Optional
    abstract val pluginMain: Property<String>
    
    @get:Input
    @get:Optional
    abstract val bootstrapper: Property<String>
    
    @get:InputFile
    @get:Optional
    abstract val bootstrapperFile: RegularFileProperty
    
    @get:Input
    @get:Optional
    abstract val loader: Property<String>
    
    @get:InputFile
    @get:Optional
    abstract val loaderFile: RegularFileProperty
    
    @get:Input
    abstract val dependencies: ListProperty<PluginDependency>
    
    @get:Input
    @get:Optional
    abstract val addonDescription: Property<String>
    
    @get:Input
    abstract val authors: ListProperty<String>
    
    @get:Input
    abstract val contributors: ListProperty<String>
    
    @get:Input
    @get:Optional
    abstract val website: Property<String>
    
    @get:Input
    @get:Optional
    abstract val prefix: Property<String>
    
    @get:Input
    abstract val libraryLoaderRepositoryUrls: ListProperty<String>
    
    @get:Input
    abstract val libraryLoaderDependencyCoordinates: ListProperty<String>
    
    @get:OutputDirectory
    abstract val output: DirectoryProperty
    
    @TaskAction
    fun run() {
        val targetDir = output.get().asFile
        targetDir.deleteRecursively()
        
        writePaperPluginYml(targetDir.resolve(PAPER_PLUGIN_YML))
        writeNovaAddonYml(targetDir.resolve(NOVA_ADDON_YML))
        
        generateBootstrapper(
            bootstrapperFile.asFile.map { it.takeIf(File::exists) }.orNull,
            targetDir.resolve(bootstrapper.getOrElse(BOOTSTRAPPER_NAME).toClassFilePath())
        )
        generateLoader(
            loaderFile.asFile.map { it.takeIf(File::exists) }.orNull,
            targetDir.resolve(loader.getOrElse(PLUGIN_LOADER_NAME).toClassFilePath())
        )
        
        if (!pluginMain.isPresent)
            generateJavaPlugin(targetDir.resolve(JAVA_PLUGIN_NAME.toClassFilePath()))
    }
    
    private fun writePaperPluginYml(path: File) {
        val pluginYml = buildString {
            appendLine("# Generated by nova-gradle-plugin")
            
            // generic metadata
            appendLine("name: ${addonName.get()}")
            appendLine("version: ${version.get()}")
            appendLine("api-version: ${Versions.PAPER_API_VERSION}")
            appendLine("authors: [${authors.get().joinToString(", ")}]")
            appendLine("contributors: [${contributors.get().joinToString(", ")}]")
            if (addonDescription.isPresent)
                appendLine("description: ${addonDescription.get()}")
            if (website.isPresent)
                appendLine("website: ${website.get()}")
            if (prefix.isPresent)
                appendLine("prefix: ${prefix.get()}")
            
            // main, loader, bootstrapper
            appendLine("main: ${pluginMain.getOrElse(JAVA_PLUGIN_NAME)}")
            appendLine("loader: ${loader.getOrElse(PLUGIN_LOADER_NAME)}")
            appendLine("bootstrapper: ${bootstrapper.getOrElse(BOOTSTRAPPER_NAME)}")
            
            // dependencies
            val bootstrapDeps = dependencies.get().filter { it.stage == PluginDependency.Stage.BOOTSTRAP }
            val serverDeps = dependencies.get().filter { it.stage == PluginDependency.Stage.SERVER }
            if (bootstrapDeps.isNotEmpty() || serverDeps.isNotEmpty()) {
                fun appendDep(dependency: PluginDependency) {
                    appendLine("    ${dependency.name}:")
                    appendLine("      load: ${dependency.load}")
                    appendLine("      required: ${dependency.required}")
                    appendLine("      join-classpath: ${dependency.joinClasspath}")
                }
                appendLine("dependencies:")
                if (bootstrapDeps.isNotEmpty()) {
                    appendLine("  bootstrap:")
                    bootstrapDeps.forEach(::appendDep)
                }
                if (serverDeps.isNotEmpty()) {
                    appendLine("  server:")
                    serverDeps.forEach(::appendDep)
                }
            }
        }
        
        path.parentFile.mkdirs()
        path.writeText(pluginYml)
    }
    
    private fun writeNovaAddonYml(path: File) {
        val addonYml = buildString {
            appendLine("# Generated by nova-gradle-plugin")
            appendLine("main: ${main.get()}")
            appendLine("nova_version: ${Versions.NOVA}")
        }
        
        path.parentFile.mkdirs()
        path.writeText(addonYml)
    }
    
    private fun generateJavaPlugin(path: File) {
        if (path.exists())
            return
        
        val javaPlugin = ClassNode(Opcodes.ASM9).apply {
            version = Opcodes.V21
            name = JAVA_PLUGIN_INTERNAL_NAME
            access = Opcodes.ACC_PUBLIC
            superName = "org/bukkit/plugin/java/JavaPlugin"
            
            methods = mutableListOf(
                // <init>
                MethodNode(
                    Opcodes.ACC_PUBLIC,
                    "<init>",
                    "()V"
                ) {
                    addLabel()
                    aLoad(0)
                    invokeSpecial("org/bukkit/plugin/java/JavaPlugin", "<init>", "()V")
                    _return()
                }
            )
        }
        
        val bin = ClassWriter(ClassWriter.COMPUTE_FRAMES).also(javaPlugin::accept).toByteArray()
        path.parentFile.mkdirs()
        path.writeBytes(bin)
    }
    
    private fun generateBootstrapper(source: File?, target: File) {
        val bootstrapper = ClassNode(Opcodes.ASM9)
        
        // default bootstrap (empty)
        val defaultBootstrap = MethodNode(
            Opcodes.ACC_PUBLIC,
            "bootstrap",
            "(Lio/papermc/paper/plugin/bootstrap/BootstrapContext;)V"
        ) {
            addLabel()
            _return()
        }
        
        // default createPlugin (calls interface default)
        val defaultCreatePlugin = MethodNode(
            Opcodes.ACC_PUBLIC,
            "createPlugin",
            "(Lio/papermc/paper/plugin/bootstrap/PluginProviderContext;)Lorg/bukkit/plugin/java/JavaPlugin;"
        ) {
            addLabel()
            aLoad(0)
            aLoad(1)
            invokeSpecial(
                "io/papermc/paper/plugin/bootstrap/PluginBootstrap",
                "createPlugin",
                "(Lio/papermc/paper/plugin/bootstrap/PluginProviderContext;)Lorg/bukkit/plugin/java/JavaPlugin;",
                isInterface = true
            )
            areturn()
        }
        
        if (source == null) {
            bootstrapper.apply {
                version = Opcodes.V21
                name = BOOTSTRAPPER_INTERNAL_NAME
                access = Opcodes.ACC_PUBLIC
                superName = "java/lang/Object"
                interfaces = listOf("io/papermc/paper/plugin/bootstrap/PluginBootstrap")
                methods = mutableListOf(
                    MethodNode(
                        Opcodes.ACC_PUBLIC,
                        "<init>",
                        "()V"
                    ) {
                        addLabel()
                        aLoad(0)
                        invokeSpecial("java/lang/Object", "<init>", "()V")
                        _return()
                    }
                )
            }
        } else {
            source.inputStream().use { ins -> ClassReader(ins).accept(bootstrapper, 0) }
        }
        
        // inserts AddonBootstrapper.bootstrap(context, getClass().getClassLoader()) at beginning
        val bootstrap = bootstrapper.methods.firstOrNull { it.name == "bootstrap" }
            ?: defaultBootstrap.also { bootstrapper.methods.add(it) }
        bootstrap.instructions.insert(buildInsnList {
            addLabel()
            aLoad(1)
            aLoad(0)
            invokeVirtual("java/lang/Object", "getClass", "()Ljava/lang/Class;")
            invokeVirtual("java/lang/Class", "getClassLoader", "()Ljava/lang/ClassLoader;")
            invokeStatic(
                "xyz/xenondevs/nova/addon/AddonBootstrapper",
                "bootstrap",
                "(Lio/papermc/paper/plugin/bootstrap/BootstrapContext;Ljava/lang/ClassLoader;)V"
            )
        })
        
        // inserts AddonBootstrapper.handleJavaPluginCreated(JavaPlugin, PluginProviderContext, ClassLoader) before return
        val createPlugin = bootstrapper.methods.firstOrNull { it.name == "createPlugin" }
            ?: defaultCreatePlugin.also { bootstrapper.methods.add(it) }
        createPlugin.insertBeforeEvery(buildInsnList {
            dup()
            aLoad(1) // PluginProviderContext
            aLoad(0)
            invokeVirtual("java/lang/Object", "getClass", "()Ljava/lang/Class;")
            invokeVirtual("java/lang/Class", "getClassLoader", "()Ljava/lang/ClassLoader;")
            invokeStatic(
                "xyz/xenondevs/nova/addon/AddonBootstrapper",
                "handleJavaPluginCreated",
                "(Lorg/bukkit/plugin/java/JavaPlugin;Lio/papermc/paper/plugin/bootstrap/PluginProviderContext;Ljava/lang/ClassLoader;)V"
            )
        }) { it.opcode == Opcodes.ARETURN }
        
        val bin = ClassWriter(ClassWriter.COMPUTE_FRAMES).also(bootstrapper::accept).toByteArray()
        target.parentFile.mkdirs()
        target.writeBytes(bin)
    }
    
    private fun generateLoader(source: File?, target: File) {
        val dependencyCoordinates = libraryLoaderDependencyCoordinates.get()
        val repositoryUrls = if (dependencyCoordinates.isNotEmpty())
            libraryLoaderRepositoryUrls.get()
        else emptyList()
        
        val loader = ClassNode(Opcodes.ASM9)
        
        if (source == null) {
            loader.apply {
                version = Opcodes.V21
                name = PLUGIN_LOADER_INTERNAL_NAME
                access = Opcodes.ACC_PUBLIC
                superName = "java/lang/Object"
                interfaces = listOf("io/papermc/paper/plugin/loader/PluginLoader")
                methods = mutableListOf(
                    // <init>
                    MethodNode(
                        Opcodes.ACC_PUBLIC,
                        "<init>",
                        "()V"
                    ) {
                        addLabel()
                        aLoad(0)
                        invokeSpecial("java/lang/Object", "<init>", "()V")
                        _return()
                    },
                )
            }
        } else {
            source.inputStream().use { ins -> ClassReader(ins).accept(loader, 0) }
        }
        
        val defaultClassloader = MethodNode(
            Opcodes.ACC_PUBLIC,
            "classloader",
            "(Lio/papermc/paper/plugin/loader/PluginClasspathBuilder;)V"
        ) {
            addLabel()
            _return()
        }
        
        // inserts library loaders calls at head
        val classloader = loader.methods.firstOrNull { it.name == "classloader" }
            ?: defaultClassloader.also { loader.methods.add(it) }
        classloader.instructions.insert(buildInsnList {
            addLabel()
            aLoad(1)
            
            // var resolver = new MavenLibraryResolver()
            new("io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver")
            dup()
            invokeSpecial("io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver", "<init>", "()V")
            
            // res.addRepository(new RemoteRepository.Builder("mavenCentral", "default", MavenLibraryResolver.MAVEN_CENTRAL_DEFAULT_MIRROR).build());
            dup()
            new($$"org/eclipse/aether/repository/RemoteRepository$Builder")
            dup()
            ldc("mavenCentral")
            ldc("default")
            getStatic("io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver", "MAVEN_CENTRAL_DEFAULT_MIRROR", "Ljava/lang/String;")
            invokeSpecial($$"org/eclipse/aether/repository/RemoteRepository$Builder", "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V")
            invokeVirtual($$"org/eclipse/aether/repository/RemoteRepository$Builder", "build", "()Lorg/eclipse/aether/repository/RemoteRepository;")
            invokeVirtual("io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver", "addRepository", "(Lorg/eclipse/aether/repository/RemoteRepository;)V")
            
            // resolver.addRepository(new RemoteRepository.Builder(repo.name, "default", repo.url).build())
            for ((i, url) in repositoryUrls.withIndex()) {
                dup()
                new($$"org/eclipse/aether/repository/RemoteRepository$Builder")
                dup()
                ldc("maven$i")
                ldc("default")
                ldc(url)
                invokeSpecial($$"org/eclipse/aether/repository/RemoteRepository$Builder", "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V")
                invokeVirtual($$"org/eclipse/aether/repository/RemoteRepository$Builder", "build", "()Lorg/eclipse/aether/repository/RemoteRepository;")
                invokeVirtual("io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver", "addRepository", "(Lorg/eclipse/aether/repository/RemoteRepository;)V")
            }
            
            // resolver.addDependency(new Dependency(new DefaultArtifact(depCoord), null))
            for (depCoord in dependencyCoordinates) {
                dup()
                new("org/eclipse/aether/graph/Dependency")
                dup()
                new("org/eclipse/aether/artifact/DefaultArtifact")
                dup()
                ldc(depCoord)
                invokeSpecial("org/eclipse/aether/artifact/DefaultArtifact", "<init>", "(Ljava/lang/String;)V")
                constNull()
                invokeSpecial("org/eclipse/aether/graph/Dependency", "<init>", "(Lorg/eclipse/aether/artifact/Artifact;Ljava/lang/String;)V")
                invokeVirtual("io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver", "addDependency", "(Lorg/eclipse/aether/graph/Dependency;)V")
            }
            
            // pluginClasspathBuilder.addLibrary(resolver)
            invokeInterface("io/papermc/paper/plugin/loader/PluginClasspathBuilder", "addLibrary", "(Lio/papermc/paper/plugin/loader/library/ClassPathLibrary;)Lio/papermc/paper/plugin/loader/PluginClasspathBuilder;")
            
            pop()
        })
        
        val bin = ClassWriter(ClassWriter.COMPUTE_FRAMES).also(loader::accept).toByteArray()
        target.parentFile.mkdirs()
        target.writeBytes(bin)
    }
    
}